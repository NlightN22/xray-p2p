#!/bin/sh

set -eu

SCRIPT_NAME=${0##*/}

NFT_SNIPPET="${NFT_SNIPPET:-/etc/nftables.d/xray-transparent.nft}"
NFT_SNIPPET_DIR="${NFT_SNIPPET_DIR:-/etc/nftables.d/xray-transparent.d}"
XRAY_INBOUND_FILE="${XRAY_INBOUND_FILE:-/etc/xray/inbounds.json}"

if [ -z "${XRAY_SELF_DIR:-}" ]; then
    case "$0" in
        */*)
            XRAY_SELF_DIR=$(CDPATH= cd -- "$(dirname "$0")" 2>/dev/null && pwd)
            export XRAY_SELF_DIR
            ;;
    esac
fi

# Guarantee XRAY_SELF_DIR is defined even when executed via stdin piping.
: "${XRAY_SELF_DIR:=}"

COMMON_LIB_REMOTE_PATH="scripts/lib/common.sh"

if ! command -v load_common_lib >/dev/null 2>&1; then
    for candidate in \
        "${XRAY_SELF_DIR%/}/scripts/lib/common_loader.sh" \
        "scripts/lib/common_loader.sh" \
        "lib/common_loader.sh"; do
        if [ -n "$candidate" ] && [ -r "$candidate" ]; then
            # shellcheck disable=SC1090
            . "$candidate"
            break
        fi
    done
fi

if ! command -v load_common_lib >/dev/null 2>&1; then
    base="${XRAY_REPO_BASE_URL:-https://raw.githubusercontent.com/NlightN22/xray-p2p/main}"
    loader_url="${base%/}/scripts/lib/common_loader.sh"
    tmp="$(mktemp 2>/dev/null)" || {
        printf 'Error: Unable to create temporary loader script.\n' >&2
        exit 1
    }
    if command -v curl >/dev/null 2>&1 && curl -fsSL "$loader_url" -o "$tmp"; then
        :
    elif command -v wget >/dev/null 2>&1 && wget -q -O "$tmp" "$loader_url"; then
        :
    else
        printf 'Error: Unable to download common loader from %s.\n' "$loader_url" >&2
        rm -f "$tmp"
        exit 1
    fi
    # shellcheck disable=SC1090
    . "$tmp"
    rm -f "$tmp"
fi

if ! command -v load_common_lib >/dev/null 2>&1; then
    printf 'Error: Unable to initialize XRAY common loader.\n' >&2
    exit 1
fi

if ! load_common_lib; then
    printf 'Error: Unable to load XRAY common library.\n' >&2
    exit 1
fi

validate_ipv4() {
    addr="$1"
    IFS_SAVE="$IFS"
    IFS='.' read -r o1 o2 o3 o4 <<EOF
$addr
EOF
    IFS="$IFS_SAVE"

    if [ -z "${o4:-}" ]; then
        return 1
    fi

    for octet in "$o1" "$o2" "$o3" "$o4"; do
        case "$octet" in
            ''|*[!0-9]*) return 1 ;;
        esac
        if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
            return 1
        fi
    done

    return 0
}

validate_subnet() {
    subnet="$1"
    case "$subnet" in
        */*) ;;
        *)
            return 1
            ;;
    esac

    addr="${subnet%/*}"
    prefix="${subnet#*/}"

    if ! validate_ipv4 "$addr"; then
        return 1
    fi

    case "$prefix" in
        ''|*[!0-9]*)
            return 1
            ;;
    esac

    if [ "$prefix" -lt 0 ] || [ "$prefix" -gt 32 ]; then
        return 1
    fi

    return 0
}

sanitize_subnet_for_filename() {
    printf '%s' "$1" | tr 'A-Z' 'a-z' | sed 's/[^0-9a-z]/_/g'
}

entry_path_for_subnet() {
    local subnet_clean
    subnet_clean=$(sanitize_subnet_for_filename "$1")
    printf '%s/xray_redirect_%s.entry' "$NFT_SNIPPET_DIR" "$subnet_clean"
}

write_subnet_entry() {
    local subnet port entry_path tmp
    subnet="$1"
    port="$2"
    if [ ! -d "$NFT_SNIPPET_DIR" ]; then
        mkdir -p "$NFT_SNIPPET_DIR"
    fi

    entry_path=$(entry_path_for_subnet "$subnet")
    tmp=$(mktemp)
    {
        printf '# Autogenerated by redirect_add.sh (formerly xray_redirect.sh) - do not edit manually.\n'
        printf 'SUBNET="%s"\n' "$subnet"
        printf 'PORT="%s"\n' "$port"
    } >"$tmp"
    chmod 0644 "$tmp"
    mv "$tmp" "$entry_path"
}

migrate_legacy_snippet() {
    local entries legacy_data entry_subnet entry_port

    if [ -d "$NFT_SNIPPET_DIR" ]; then
        entries=$(find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' 2>/dev/null | head -n 1 || true)
        if [ -n "$entries" ]; then
            return
        fi
    fi

    if [ ! -s "$NFT_SNIPPET" ]; then
        return
    fi

    legacy_data=$(awk '
        /meta l4proto tcp tcp dport !=/ {
            port=""
            subnet=""
            for (i = 1; i <= NF; i++) {
                if ($i == "!=") {
                    if ((i+1) <= NF) {
                        port=$(i+1)
                    }
                } else if ($i == "daddr") {
                    if ((i+1) <= NF) {
                        subnet=$(i+1)
                    }
                }
            }
            if (port != "" && subnet != "") {
                print port " " subnet
            }
        }
    ' "$NFT_SNIPPET")

    if [ -z "$legacy_data" ]; then
        return
    fi

    while IFS= read -r line; do
        entry_port=${line%% *}
        entry_subnet=${line#* }
        if [ -z "$entry_port" ] || [ -z "$entry_subnet" ]; then
            continue
        fi
        write_subnet_entry "$entry_subnet" "$entry_port"
    done <<EOF
$legacy_data
EOF
}

usage() {
    cat <<EOF
Usage: $SCRIPT_NAME [options] [SUBNET]

Configure nftables redirect entries for XRAY transparent proxy routing.

Options:
  -h, --help        Show this help message and exit.

Arguments:
  SUBNET            Optional destination subnet in CIDR notation (e.g. 10.0.101.0/24).
                    When omitted, the script prompts for the subnet interactively.

Environment variables:
  NFT_SNIPPET           Override the nftables snippet file path (default: /etc/nftables.d/xray-transparent.nft).
  NFT_SNIPPET_DIR       Override the directory storing per-subnet entries (default: /etc/nftables.d/xray-transparent.d).
  XRAY_INBOUND_FILE     Path to the XRAY inbounds definition used to detect dokodemo-door ports
                        (default: /etc/xray/inbounds.json).
  XRAY_REPO_BASE_URL    Custom base URL to fetch the common loader when not running inside the repo.
EOF
    exit "${1:-0}"
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
    usage 0
fi

if [ "$#" -gt 1 ]; then
    usage 1
fi

SUBNET="${1:-}"

if [ -z "$SUBNET" ]; then
    if [ -t 0 ]; then
        printf 'Enter destination subnet (CIDR, e.g. 10.0.101.0/24): '
        IFS= read -r SUBNET
    elif [ -r /dev/tty ]; then
        printf 'Enter destination subnet (CIDR, e.g. 10.0.101.0/24): '
        IFS= read -r SUBNET </dev/tty
    else
        xray_die "Subnet argument is required"
    fi
fi

if [ -z "$SUBNET" ]; then
    xray_die "Subnet cannot be empty"
fi

if ! validate_subnet "$SUBNET"; then
    xray_die "Subnet must be a valid IPv4 CIDR (example: 10.0.101.0/24 with prefix between 0 and 32)"
fi

if [ ! -f "$XRAY_INBOUND_FILE" ]; then
    xray_die "XRAY inbound file $XRAY_INBOUND_FILE not found"
fi

xray_require_cmd nft

select_dokodemo_port() {
    if command -v jq >/dev/null 2>&1; then
        jq -r '.inbounds[] | select(.protocol == "dokodemo-door") | .port' "$XRAY_INBOUND_FILE" 2>/dev/null | grep -E '^[0-9]+$'
        return
    fi

    if command -v jsonfilter >/dev/null 2>&1; then
        jsonfilter -i "$XRAY_INBOUND_FILE" -e '@.inbounds[@.protocol="dokodemo-door"].port' 2>/dev/null | grep -E '^[0-9]+$'
        return
    fi

    awk '
        BEGIN { port=""; want_port=0 }
        /\{/ { port=""; want_port=0 }
        /"port"[[:space:]]*:/ {
            match($0, /[0-9]+/, m)
            port=m[0]
            if (want_port) {
                print port
                want_port=0
            }
        }
        /"protocol"[[:space:]]*:[[:space:]]*"dokodemo-door"/ {
            if (port != "")
                print port
            else
                want_port=1
        }
        /\}/ { port=""; want_port=0 }
    ' "$XRAY_INBOUND_FILE"
}

ports=$(select_dokodemo_port || true)
if [ -z "$ports" ]; then
    xray_die "No dokodemo-door inbounds found in $XRAY_INBOUND_FILE"
fi

count=$(printf '%s\n' "$ports" | wc -l)
if [ "$count" -eq 1 ]; then
    PORT="$ports"
else
    xray_log "Multiple dokodemo-door ports detected:"
    idx=1
    printf '%s\n' "$ports" | while IFS= read -r port; do
        printf ' [%d] %s\n' "$idx" "$port"
        idx=$((idx + 1))
    done
    if [ -t 0 ]; then
        printf 'Select port number: '
        read -r answer
    elif [ -r /dev/tty ]; then
        printf 'Select port number: '
        read -r answer </dev/tty
    else
        xray_die "Multiple dokodemo-door ports found but no interactive input available"
    fi

    case "$answer" in
        *[!0-9]*) xray_die "Invalid selection" ;;
    esac
    if [ "$answer" -lt 1 ] || [ "$answer" -gt "$count" ]; then
        xray_die "Selection out of range"
    fi
    PORT=$(printf '%s\n' "$ports" | sed -n "${answer}p")
fi

xray_log "Configuring transparent redirect via nftables: subnet=$SUBNET port=$PORT"

write_nft_snippet() {
    local dir tmp entries entry
    dir=$(dirname "$NFT_SNIPPET")
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
    fi
    if [ ! -d "$NFT_SNIPPET_DIR" ]; then
        mkdir -p "$NFT_SNIPPET_DIR"
    fi

    entries=$(find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' -print 2>/dev/null | sort)
    if [ -z "$entries" ]; then
        rm -f "$NFT_SNIPPET"
        return
    fi

    tmp=$(mktemp)
    {
        cat <<'NFT'
# Autogenerated by redirect_add.sh (formerly xray_redirect.sh) - do not edit manually.
chain xray_transparent_prerouting {
    type nat hook prerouting priority dstnat + 5; policy accept;
NFT
        printf '%s\n' "$entries" | while IFS= read -r entry; do
            SUBNET=''
            PORT=''
            # shellcheck disable=SC1090
            . "$entry"
            if [ -z "$SUBNET" ] || [ -z "$PORT" ]; then
                continue
            fi
            printf '    meta l4proto tcp tcp dport != %s ip daddr %s counter redirect to :%s\n' "$PORT" "$SUBNET" "$PORT"
        done
        cat <<'NFT'
}

chain xray_transparent_output {
    type nat hook output priority dstnat + 5; policy accept;
NFT
        printf '%s\n' "$entries" | while IFS= read -r entry; do
            SUBNET=''
            PORT=''
            # shellcheck disable=SC1090
            . "$entry"
            if [ -z "$SUBNET" ] || [ -z "$PORT" ]; then
                continue
            fi
            printf '    meta l4proto tcp tcp dport != %s ip daddr %s counter redirect to :%s\n' "$PORT" "$SUBNET" "$PORT"
        done
        cat <<'NFT'
}
NFT
    } >"$tmp"

    chmod 0644 "$tmp"
    mv "$tmp" "$NFT_SNIPPET"
}

migrate_legacy_snippet
entry_file=$(entry_path_for_subnet "$SUBNET")
write_subnet_entry "$SUBNET" "$PORT"
write_nft_snippet

if command -v fw4 >/dev/null 2>&1; then
    if fw4 reload >/dev/null; then
        xray_log "fw4 reload ok"
    else
        xray_log "fw4 reload failed; falling back to direct nft"
        if ! nft -f "$NFT_SNIPPET"; then
            xray_die "Failed to load nft rules"
        fi
    fi
else
    xray_log "fw4 binary not found; applying nft snippet directly"
    if ! nft -f "$NFT_SNIPPET"; then
        xray_die "Failed to load nft rules"
    fi
fi

xray_log "Transparent redirect active for subnet $SUBNET"
xray_log "Dokodemo-door port: $PORT"
xray_log "Snippet file: $NFT_SNIPPET"
xray_log "Entry file: $entry_file"

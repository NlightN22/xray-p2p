#!/bin/sh

[ "${REDIRECT_LIB_LOADED:-0}" -eq 1 ] && return 0
REDIRECT_LIB_LOADED=1

redirect_sanitize_subnet_for_filename() {
    printf '%s' "$1" | tr 'A-Z' 'a-z' | sed 's/[^0-9a-z]/_/g'
}

redirect_entry_path_for_subnet() {
    local cleaned
    cleaned=$(redirect_sanitize_subnet_for_filename "$1")
    printf '%s/xray_redirect_%s.entry' "$NFT_SNIPPET_DIR" "$cleaned"
}

redirect_find_entries() {
    [ -d "$NFT_SNIPPET_DIR" ] || return 0
    find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' -print 2>/dev/null | sort
}

redirect_write_entry() {
    local subnet="$1" port="$2" path tmp
    [ -d "$NFT_SNIPPET_DIR" ] || mkdir -p "$NFT_SNIPPET_DIR"
    path=$(redirect_entry_path_for_subnet "$subnet")
    tmp=$(mktemp 2>/dev/null) || xray_die "Unable to create temporary entry file"
    {
        printf '# Autogenerated by redirect.sh - do not edit manually.\n'
        printf 'SUBNET="%s"\n' "$subnet"
        printf 'PORT="%s"\n' "$port"
    } >"$tmp"
    chmod 0644 "$tmp" 2>/dev/null || true
    mv "$tmp" "$path"
    printf '%s\n' "$path"
}

redirect_emit_chain() {
    local name="$1" hook="$2" priority="$3" entries="$4"
    printf 'chain %s {\n    type nat hook %s priority %s; policy accept;\n' "$name" "$hook" "$priority"
    printf '%s\n' "$entries" | while IFS= read -r entry; do
        [ -n "$entry" ] || continue
        SUBNET=''
        PORT=''
        # shellcheck disable=SC1090
        . "$entry"
        [ -n "$SUBNET" ] && [ -n "$PORT" ] && printf '    meta l4proto tcp tcp dport != %s ip daddr %s counter redirect to :%s\n' "$PORT" "$SUBNET" "$PORT"
    done
    printf '}\n'
}

redirect_generate_snippet() {
    local entries tmp dir
    entries="$(redirect_find_entries || true)"
    if [ -z "${entries:-}" ]; then
        rm -f "$NFT_SNIPPET"
        return 1
    fi
    dir=$(dirname "$NFT_SNIPPET")
    [ -d "$dir" ] || mkdir -p "$dir"
    tmp=$(mktemp 2>/dev/null) || xray_die "Unable to create temporary nft snippet"
    {
        printf '# Autogenerated by redirect.sh - do not edit manually.\n'
        redirect_emit_chain "xray_transparent_prerouting" "prerouting" "dstnat + 5" "$entries"
        redirect_emit_chain "xray_transparent_output" "output" "-95" "$entries"
    } >"$tmp"
    chmod 0644 "$tmp" 2>/dev/null || true
    mv "$tmp" "$NFT_SNIPPET"
    return 0
}

redirect_cleanup_chains() {
    local chain
    for chain in xray_transparent_prerouting xray_transparent_output; do
        if nft list chain inet fw4 "$chain" >/dev/null 2>&1; then
            nft flush chain inet fw4 "$chain" >/dev/null 2>&1 || true
            if nft delete chain inet fw4 "$chain" >/dev/null 2>&1; then
                xray_log "Removed chain inet fw4 $chain"
            else
                xray_log "Failed to delete chain inet fw4 $chain"
            fi
        fi
    done
}

redirect_apply_rules() {
    local snippet_present=0
    [ -f "$NFT_SNIPPET" ] && snippet_present=1
    if command -v fw4 >/dev/null 2>&1; then
        if fw4 reload >/dev/null 2>&1; then
            xray_log "fw4 reload ok"
            return
        fi
        if [ "$snippet_present" -eq 1 ]; then
            xray_log "fw4 reload failed; applying nft snippet directly"
        else
            xray_log "fw4 reload failed; attempting direct cleanup"
        fi
    else
        if [ "$snippet_present" -eq 1 ]; then
            xray_log "fw4 binary not found; applying nft snippet directly"
        else
            xray_log "fw4 binary not found; attempting direct cleanup"
        fi
    fi
    xray_require_cmd nft
    if [ "$snippet_present" -eq 1 ]; then
        if ! nft -f "$NFT_SNIPPET"; then
            xray_die "Failed to load nft rules"
        fi
        return
    fi
    redirect_cleanup_chains
}

redirect_select_port() {
    [ -f "$XRAY_INBOUND_FILE" ] || xray_die "XRAY inbound file $XRAY_INBOUND_FILE not found"
    if command -v jq >/dev/null 2>&1; then
        jq -r '.inbounds[] | select(.protocol == "dokodemo-door") | .port' "$XRAY_INBOUND_FILE" 2>/dev/null | grep -E '^[0-9]+$'
        return
    fi
    if command -v jsonfilter >/dev/null 2>&1; then
        jsonfilter -i "$XRAY_INBOUND_FILE" -e '@.inbounds[@.protocol="dokodemo-door"].port' 2>/dev/null | grep -E '^[0-9]+$'
        return
    fi
    awk '
        BEGIN { port=""; want_port=0 }
        /\{/ { port=""; want_port=0 }
        /"port"[[:space:]]*:/ {
            match($0, /[0-9]+/, m)
            port=m[0]
            if (want_port) {
                print port
                want_port=0
            }
        }
        /"protocol"[[:space:]]*:[[:space:]]*"dokodemo-door"/ {
            if (port != "")
                print port
            else
                want_port=1
        }
        /\}/ { port=""; want_port=0 }
    ' "$XRAY_INBOUND_FILE"
}

redirect_migrate_legacy_snippet() {
    local entries legacy line entry_port entry_subnet tmp
    if [ -d "$NFT_SNIPPET_DIR" ]; then
        entries=$(find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' 2>/dev/null | head -n 1 || true)
        [ -n "$entries" ] && return 0
    fi
    [ -s "$NFT_SNIPPET" ] || return 0
    legacy=$(awk '
        /meta l4proto tcp tcp dport !=/ {
            port=""
            subnet=""
            for (i = 1; i <= NF; i++) {
                if ($i == "!=" && (i+1) <= NF) {
                    port=$(i+1)
                } else if ($i == "daddr" && (i+1) <= NF) {
                    subnet=$(i+1)
                }
            }
            if (port != "" && subnet != "")
                print port " " subnet
        }
    ' "$NFT_SNIPPET")
    [ -n "$legacy" ] || return 0
    mkdir -p "$NFT_SNIPPET_DIR"
    while IFS= read -r line; do
        entry_port=${line%% *}
        entry_subnet=${line#* }
        [ -n "$entry_port" ] && [ -n "$entry_subnet" ] || continue
        tmp=$(mktemp 2>/dev/null) || xray_die "Unable to create temporary entry during migration"
        {
            printf '# Autogenerated by redirect.sh migration - do not edit manually.\n'
            printf 'SUBNET="%s"\n' "$entry_subnet"
            printf 'PORT="%s"\n' "$entry_port"
        } >"$tmp"
        chmod 0644 "$tmp" 2>/dev/null || true
        mv "$tmp" "$(redirect_entry_path_for_subnet "$entry_subnet")"
    done <<EOF
$legacy
EOF

    return 0
}

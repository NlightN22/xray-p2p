#!/bin/sh

set -eu

NFT_SNIPPET="/etc/nftables.d/xray-transparent.nft"
NFT_SNIPPET_DIR="/etc/nftables.d/xray-transparent.d"

log() {
    printf '%s\n' "$*"
}

die() {
    printf 'Error: %s\n' "$*" >&2
    exit 1
}

require_cmd() {
    cmd="$1"
    if command -v "$cmd" >/dev/null 2>&1; then
        return
    fi

    case "$cmd" in
        nft)
            die "Required command 'nft' not found. Install nftables (e.g. opkg update && opkg install nftables)."
            ;;
        *)
            die "Required command '$cmd' not found. Install it before running this script."
            ;;
    esac
}

validate_ipv4() {
    addr="$1"
    IFS_SAVE="$IFS"
    IFS='.' read -r o1 o2 o3 o4 <<EOF
$addr
EOF
    IFS="$IFS_SAVE"

    if [ -z "${o4:-}" ]; then
        return 1
    fi

    for octet in "$o1" "$o2" "$o3" "$o4"; do
        case "$octet" in
            ''|*[!0-9]*) return 1 ;;
        esac
        if [ "$octet" -lt 0 ] || [ "$octet" -gt 255 ]; then
            return 1
        fi
    done

    return 0
}

validate_subnet() {
    subnet="$1"
    case "$subnet" in
        */*) ;;
        *)
            return 1
            ;;
    esac

    addr="${subnet%/*}"
    prefix="${subnet#*/}"

    if ! validate_ipv4 "$addr"; then
        return 1
    fi

    case "$prefix" in
        ''|*[!0-9]*)
            return 1
            ;;
    esac

    if [ "$prefix" -lt 0 ] || [ "$prefix" -gt 32 ]; then
        return 1
    fi

    return 0
}

sanitize_subnet_for_filename() {
    printf '%s' "$1" | tr 'A-Z' 'a-z' | sed 's/[^0-9a-z]/_/g'
}

entry_path_for_subnet() {
    local subnet_clean
    subnet_clean=$(sanitize_subnet_for_filename "$1")
    printf '%s/xray_redirect_%s.entry' "$NFT_SNIPPET_DIR" "$subnet_clean"
}

usage() {
    cat <<'USAGE'
Usage: xray_redirect_remove.sh [SUBNET | --all]

Removes nftables snippets installed by xray_redirect.sh.

  SUBNET   Specific subnet (CIDR) to remove.
  --all    Remove every subnet (default if no argument supplied).
USAGE
}

if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
    usage
    exit 0
fi

MODE="all"
TARGET_SUBNET=""

if [ "$#" -gt 0 ]; then
    case "$1" in
        --all)
            MODE="all"
            shift
            ;;
        *)
            MODE="single"
            TARGET_SUBNET="$1"
            shift
            ;;
    esac
fi

if [ "$#" -gt 0 ]; then
    usage
    exit 1
fi

if [ "$MODE" = "single" ]; then
    if ! validate_subnet "$TARGET_SUBNET"; then
        die "Subnet must be a valid IPv4 CIDR (example: 10.0.101.0/24 with prefix between 0 and 32)"
    fi
fi

rebuild_nft_snippet() {
    local dir tmp entries entry
    dir=$(dirname "$NFT_SNIPPET")
    if [ ! -d "$dir" ]; then
        mkdir -p "$dir"
    fi
    if [ ! -d "$NFT_SNIPPET_DIR" ]; then
        mkdir -p "$NFT_SNIPPET_DIR"
    fi

    entries=$(find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' -print 2>/dev/null | sort)
    if [ -z "$entries" ]; then
        rm -f "$NFT_SNIPPET"
        return
    fi

    tmp=$(mktemp)
    {
        cat <<'NFT'
# Autogenerated by xray_redirect.sh - do not edit manually.
chain xray_transparent_prerouting {
    type nat hook prerouting priority dstnat + 5; policy accept;
NFT
        printf '%s\n' "$entries" | while IFS= read -r entry; do
            SUBNET=''
            PORT=''
            # shellcheck disable=SC1090
            . "$entry"
            if [ -z "$SUBNET" ] || [ -z "$PORT" ]; then
                continue
            fi
            printf '    meta l4proto tcp tcp dport != %s ip daddr %s counter redirect to :%s\n' "$PORT" "$SUBNET" "$PORT"
        done
        cat <<'NFT'
}

chain xray_transparent_output {
    type nat hook output priority dstnat + 5; policy accept;
NFT
        printf '%s\n' "$entries" | while IFS= read -r entry; do
            SUBNET=''
            PORT=''
            # shellcheck disable=SC1090
            . "$entry"
            if [ -z "$SUBNET" ] || [ -z "$PORT" ]; then
                continue
            fi
            printf '    meta l4proto tcp tcp dport != %s ip daddr %s counter redirect to :%s\n' "$PORT" "$SUBNET" "$PORT"
        done
        cat <<'NFT'
}
NFT
    } >"$tmp"

    chmod 0644 "$tmp"
    mv "$tmp" "$NFT_SNIPPET"
}

migrate_legacy_snippet() {
    local entries legacy_data entry_subnet entry_port

    if [ -d "$NFT_SNIPPET_DIR" ]; then
        entries=$(find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' 2>/dev/null | head -n 1 || true)
        if [ -n "$entries" ]; then
            return
        fi
    fi

    if [ ! -s "$NFT_SNIPPET" ]; then
        return
    fi

    legacy_data=$(awk '
        /meta l4proto tcp tcp dport !=/ {
            port=""
            subnet=""
            for (i = 1; i <= NF; i++) {
                if ($i == "!=") {
                    if ((i+1) <= NF) {
                        port=$(i+1)
                    }
                } else if ($i == "daddr") {
                    if ((i+1) <= NF) {
                        subnet=$(i+1)
                    }
                }
            }
            if (port != "" && subnet != "") {
                print port " " subnet
            }
        }
    ' "$NFT_SNIPPET")

    if [ -z "$legacy_data" ]; then
        return
    fi

    mkdir -p "$NFT_SNIPPET_DIR"

    while IFS= read -r line; do
        entry_port=${line%% *}
        entry_subnet=${line#* }
        if [ -z "$entry_port" ] || [ -z "$entry_subnet" ]; then
            continue
        fi
        tmp_path=$(mktemp)
        {
            printf '# Autogenerated by xray_redirect.sh - do not edit manually.\n'
            printf 'SUBNET="%s"\n' "$entry_subnet"
            printf 'PORT="%s"\n' "$entry_port"
        } >"$tmp_path"
        chmod 0644 "$tmp_path"
        mv "$tmp_path" "$(entry_path_for_subnet "$entry_subnet")"
    done <<EOF
$legacy_data
EOF
}

migrate_legacy_snippet

case "$MODE" in
    all)
        if [ -d "$NFT_SNIPPET_DIR" ]; then
            find "$NFT_SNIPPET_DIR" -maxdepth 1 -type f -name '*.entry' -print 2>/dev/null | while IFS= read -r file; do
                rm -f "$file"
                log "Removed entry $file"
            done
        fi
        if [ -f "$NFT_SNIPPET" ]; then
            rm -f "$NFT_SNIPPET"
            log "Removed nftables snippet $NFT_SNIPPET"
        else
            log "Snippet $NFT_SNIPPET not present"
        fi
        ;;
    single)
        target_entry=$(entry_path_for_subnet "$TARGET_SUBNET")
        if [ -f "$target_entry" ]; then
            rm -f "$target_entry"
            log "Removed entry $target_entry"
        else
            log "Entry for subnet $TARGET_SUBNET not present"
        fi
        ;;
esac

rebuild_nft_snippet

fw4_ok=0
if command -v fw4 >/dev/null 2>&1; then
    if fw4 reload >/dev/null 2>&1; then
        fw4_ok=1
        log "fw4 reload ok"
    else
        log "fw4 reload failed; attempting direct nft cleanup"
    fi
else
    log "fw4 binary not found; attempting direct nft cleanup"
fi

if [ "$fw4_ok" -eq 0 ]; then
    require_cmd nft

    delete_chain() {
        chain_name="$1"
        if nft list chain inet fw4 "$chain_name" >/dev/null 2>&1; then
            nft flush chain inet fw4 "$chain_name" >/dev/null 2>&1 || true
            if nft delete chain inet fw4 "$chain_name" >/dev/null 2>&1; then
                log "Removed chain inet fw4 $chain_name"
            else
                log "Failed to delete chain inet fw4 $chain_name"
            fi
        fi
    }

    delete_chain xray_transparent_prerouting
    delete_chain xray_transparent_output
fi

log "Transparent redirect rules removed"
